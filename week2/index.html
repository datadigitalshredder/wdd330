<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week2 - notes and exercises</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&family=Noto+Sans&display=swap" rel="stylesheet">
    <script defer src="js/week2.js"></script>
</head>
<body>
    <h1>Week 2</h1>
    <h2 class="notes-header">Notes</h2>
    <section class="notes"><h3>Programming basics - JavaScript: Novice to Ninja</h3>
        <li>The syntax used by JavaScript is known as a C-style syntax because of its similarities
        with the C programming language. It's considered best practice to combine the two and write each 
        statement on a new line, terminated by a semi-colon.</li>
        <li>JavaScript has seven different data types. Six of them are primitive data types and are listed below:
            <ol>
                <li>String</li>
                <li>Symbol (The symbol primitive data type was only introduced in ES6.)</li>
                <li>Number</li>
                <li>Boolean</li>
                <li>Undefined</li>
                <li>Null</li>
            </ol>
        </li>
        <li>The other data type is object, which includes, arrays, functions and object literals.
        </li>
        <li>The typeof operator is used in Javascript to find the type of value. Eg, <br>
            console.log(typeof 10);<br>
            ~ number<br>
            console.log(typeof false);<br>
            ~ boolean<br>
            console.log(typeof { ninja: 'turtle' });<br>
            ~ object
        </li>
        <li>Variables are used in programming languages to refer to a value stored in memory. <br>
            <strong>VARIABLES MUST be declared before they are used.</strong>  
        </li>
        <li>From ES6 onwards, JavaScript uses the keywords <em>const</em> and <em>let</em> to declare variables. The 
            keyword <em>const</em> is used when the variable will not be reassigned to another value, whereas 
            <em>let</em> is used if the variable might be reassigned later in the program.<br>
            Assignment is done using the "=" operator.<br>
            Variables can be declared and assigned multiple at the same time separated with commas:<br>
            let x = 3, y = 4, z = 5;<br>
            Variables that have been declared using the let keyword can be reassigned to another value at some point 
            later in the program. Eg, <br>
            let points = 25;<br>
            console.log(points);<br>
            ~ 25<br>
            points = 40;<br>
            console.log(points);<br>
            ~ 40<br>
            <strong>Local Scope examples</strong><br>
            const a = 1;<br>
            
            { const a = 3;<br>
              a; <br>
              console.log(a);<br>
              ~ 3<br>
            }<br>
            console.log(a);<br>
            ~ 1<br>
            <p>In the example, a is initially defined globally outside the block and is given the value of 1. This 
                means it has global scope and is available inside and outside the block. But then a is defined inside 
                the local block using let. This gives it local scope inside the block where it has a value of 3, but 
                it retains the value of 1 outside the block. For all intents and purposes, the two a variables are 
                different variables.</p>

            let b = 2;<br>
            { b = 4; <br>
            b; <br>
            console.log(b);<br>
            ~ 4<br>
            }<br>
            console.log(b);<br>
            ~ 4<br>
            <p>In this example, b is defined globally outside the block and given the value of 2. Then we reassign the 
                value of b to 4 inside the block, but without using let. This means that it still refers to the global 
                variable outside the block, so the value of b is the same both inside and outside the block and it 
                gets overwritten globally to be a value of 4.</p>

            { c = 5; <br>
              c; <br>
            }<br>
            console.log(c);<br>
            ~ 5<br>
            <p>In this example, c is defined inside the block, but because this is done without using let or const, it 
                has global scope and is also available outside the block.</p>

            { const d = 6; d; }<br>
            console.log(d);<br>
            ~ ReferenceError: d is not defined<br>
            <p>In this example, d is defined inside the block, but by using const so it has local scope and is only 
                accessible inside the block. When we try to log the value of d outside the block, it causes an error 
                because d is not defined globally.</p>
            <p><em>Using let or const to declare variables will ensure they are block scoped, and it is good practice 
                to always use them to declare variables. In general, if a value is unlikely to change in your code 
                then you should declare it using const, and let should only be used for storing values that will need 
                to be reassigned while the program is running.</em></p>
        </li>
        <li>Direct Assignment and Assignment By Reference<br>
            <em>Direct assignement</em><br>
            const a = 1;<br>
            let b = a;<br> ~ a = 1, b = 1<br>
            <p>In the example above, a references the primitive number 1. We then assign b to the same value as a. At 
                this point a and b both have the same value of 1. Then we reassign the value of 2 to b, but the a 
                still has a value of 1.</p>

            b = 2;<br> ~ a = 1, b = 2<br>
            <em>Assignment by reference</em><br>
            const c = { value: 1 };<br>
            let d = c;<br> ~ c.value = 1, d.value = 1<br>
            d.value = 2;<br> ~ c.value = 2, d.value = 2<br>
            <p>In the example above, the change to the value property of d also results in the value property of c 
                changing as well. This is because the variables c and d are both referencing the same object, so any 
                changes to one of them will also affect the other.</p>
        </li>
        <li>Strings<br>
            new String("hello")<br>
            [String: 'hello']<br>
        </li>
        <li>String Properties and Methods<br>
        <p>Primitive data types and objects have properties and methods. Properties are information about the object 
            or value, while methods perform an action on the object or value â€• either to change it or to tell us 
            something about it.</p>
        <p><em>We can access the properties of a string using dot notation. This involves writing a dot followed by 
            the property we are interested in. For example, every string has a length property that tells us how many 
            characters are in the string:</em></p>
            const name = 'Alexa'; // declare and assign a variable<br>
            ~ 'Alexa'<br>
            
            name.length; // retrieve the name variable's length property<br>
            ~ 5<br>
            <p>All properties of primitive data types are immutable, meaning they're unable to be changed.</p>
        </li>
        <li>Converting Strings to Numbers<br>
            Number('23');<br>
            const answer = '5' * 1;<br>
            const answer = +'5';<br>
        </li>
        <li>Converting Numbers to Strings<br>
            String(3);<br>
            3 +'';<br>
            10..toString();<br>
            10..toString(2);<br>
            parseInt('23',10); // 23 is the string to convert to a number in base 10<br>
            parseInt('2.4',10);<br>
            parseFloat('2.9',10);<br>
        </li>
        <li>In contrast, using <em>const</em>means you can't reassign the variable to another value.</em></li>
        <li>Using <em>const</em> does not it immutable when working with non-primitive data types, for example: <br>
            const name = { value: 'Alexa' }; // an object <br>
            name.value = 'Siri'; // change the value <br>
            ~ Siri</li>
        <li>The <em>const</em> variabel should be used to declare most variables. This helps to prevent bugs from 
            reassigning the varibles unexpectedly</li>
        <li>let and const have block scope.</li>
        <li>A core tenet of the JavaScript language is that it has to remain backwardly compatible. This 
            means that the behavior of var had to remain consistent, so couldn't just be changed in ES6. For 
            that reason, the new keyword let was introduced.</li>
        <li>Using const and let to declare variables means they are block scoped, so their value only exists 
            inside the block they are declared in.</li>
        <li>Scope refers to where a constant or variable is accessible by the program.</li>
        <li>Any variable declared outside of a block is said to have global scope. This means it is 
            accessible everywhere in the program. NOT a good approach.</li>
        <li>In ES6, blocks can be used to create a local scope. This means that any variables defined inside a block 
            using the let or const will only be available inside that block and not be accessible outside of that 
            block.</li>
        <h3>Arrays, Logic and Loops</h3>
        <li>Arrays<br> No notes on arrays</li>
        <li>Sets
            <p>A set is a data structure that represents a collection of unique values, so it cannot include any 
                duplicate values.<br> Sets offer a useful way to keep track of data without having to check if any 
                values have been duplicated. It's also quick and easy to check if a particular value is in a set, 
                which can be a slow operation if an array is used.</p>
            <p>Creating a set</p>
            <p>const list = new Set();</p>
            <p>Adding values to a Set<br>list.add(1);</p>
            <p>OR<br>list.add(2).add(3).add(4);</p>
            <p>If you try to add a value that is already contained in the set, then the operation is simply ignored</p>
            <p>If a string is used as the argument then each character will be added as a separate element, with any 
                repeated characters ignored:<br> const letters = new Set('hello');<br>Set { 'h', 'e', 'l', 'o' }</p>
            <p>Use this instead for strings<br>const words = new Set().add('the').add('quick').add('brown').add('fox');</p>
            <p>All non-primitive values, such as arrays and objects, are considered unique values, even if they contain 
                the same values.</p>
            <p>const arrays = new Set().add([1]).add([1]);<br>
                arrays<br>
                Set { [ 1 ], [ 1 ] }</p>
        </li>
        <li>Converting Sets to Arrays
            <p>A set can be converted into an array by placing the set, along with the spread operator directly inside 
                an array literal.<br>const shoppingSet = new Set().add('Apples').add('Bananas').add('Beans');<br>
                const shoppingArray = [...shoppingSet];<br> ~ [ 'Apples', 'Bananas', 'Beans' ]<br> OR use:<br>
                const shoppingArray = Array.from(shoppingSet);</p>
            <p>Creating a copy of an array with any duplicate values removed:<br>
                const duplicate = [3, 1, 4, 1, 5, 9, 2, 6 ,5,3,5,9];<br>
                const nonDuplicate = [...new Set(repeatedArray)];<br>
                ~ [ 3, 1, 4, 5, 9, 2, 6 ]</p>
        </li>
        <li>Maps
            <p>An empty map object can be created using the new operator and Map() constructor. There is, at the time 
                of writing, no literal notation for creating maps.<br>const romanNumerals = new Map();</p>
        </li>
        <li>Converting Maps to Arrays
            <p>Maps can be converted into a nested array of key-value pairs in a similar way to sets; using either the 
                spread operator:</p>
        </li>
        <li>Logic
            if (condition) {<br>
                // code to run if condition is true<br>
                } else {<br>
                // code to run if condition is false<br>
                }<br>
            Example<br>
            const n = 12;<br>
            if (n%2 === 0) {<br>
                console.log('n is an even number');<br>
            } else {<br>
                console.log('n is an odd number');<br>
            }<br>
            ~ 'n is an even number'<br>
            <p>Ternary operators can be used instead<br>
                condition ? (//code to run if condition is true) : (//code to run if condition is false)<br>
                const n = 5;<br>
                n%2 === 0 ? console.log('n is an even number') : console.log('n is an odd number');<br>
                ~ 'n is an odd number'<br></p>
            <p>Switch Statements</p>
            <p>You can actually string lots of if and else statements together to make a logical decision tree</p>
            <p>You can actually string lots of if and else statements together to make a logical decision tree</p>
        </li>
        <li>Loops
            <p>The while loop<br>
                This will repeatedly run a block of code while a certain condition is true, and takes the following structure:<br>
                while (condition) {<br>
                    // do something<br>
                }<br>
                Infinite loops<br>
                It is important that the condition in a while loop will be met at some point, otherwise your code will 
                get stuck in an infinite loop that could possibly crash the program.<br>
                Example, <br>
                let n = 1;<br>
                while(n>0){<br>
                    console.log('Hello');<br>
                    n++;<br>
                }<br>
                This loop will keep running, as the variable n will always be above zero. Most browsers will warn you 
                that there is a slow running script when this happens and give you the option to stop it. If not, you 
                can kill the process by closing the tab or restarting the browser. Obviously you want to avoid this 
                happening, though; especially with public-facing code.
            </p>
            <p>do while Loop<br>
                A do ... while loop is similar to a while loop. The only difference is that the condition comes after 
                the block of code:<br>
                do {<br>
                    do something<br>
                } while(condition)<br>
            </p>
            <p>For loop<br>
                for (initialization ; condition ; after) { do something }<br>
                The initialization code is run before the loop starts and is usually employed to initialize any 
                variables used in the loop. The condition has to be satisfied for the loop to continue. The after code 
                is what to do after each iteration of the loop, and it is typically used to increment a counter of 
                some sort. Here's the green bottles example written as a for loop: <br>
                for (let bottles = 10 ; bottles > 0 ; bottles--) {<br>
                    console.log(`There were ${bottles} green bottles, hanging on a wall. And if one green bottle <br>
                    should accidentally fall, there'd be ${bottles-1} green bottles hanging on the wall`);<br>
                }<br>
            </p>
            <p><strong>A while loop, a do ... while loop, or a for loop can be used to achieve the same results.</strong></p>
        </li>
        <li><p>Nested for Loops</p>
            <p>Loops inside loops
            </p>
        </li>
        <li><p>Looping over Arrays</p>
            <p>Array indices start their numbering at zero, so make sure the value of the initial counter in the for 
                loop also starts at zero. We want the loop to continue until it reaches the length of the array; this 
                can be set as the variable max in the initialization part of the for loop, then the condition becomes 
                i less than max. This is preferable to using i less than avengers.length because then the length of the avengers array 
                would have to be calculated after every pass through the loop. This might not sound all that 
                important, but it can make a big difference to the speed of the program when using large arrays.</p>
            <p><strong>ES6 introduced an improved iterator function for arrays called a for-of loop that uses a slightly different syntax</strong></p>
        </li>
        <li><p>Looping Over Sets</p>
            <p>Sets are enumerable, which means they have methods that allow you to loop over each value in the set. 
                The loop will iterate over each value in the same order they were added to the set.</p>
        </li>
        <li><p>Looping Over Maps</p>
            <p>Maps are also enumerable, so it's also possible to loop over a map in a similar way to a set. The loop 
                will iterate over each key-value pair in the same order as they were added to the map.</p>

        </li>
        <h3>Functions - JavaScript: Novice to Ninja</h3>
        <li>
            See the console for examples on Functions.
        </li>
        <li>
            <p>Arrow Functions</p>
            <p>ES6 introduced a new syntax for declaring functions called the arrow syntax. These make declaring 
                functions much more succinct by using less verbose syntax.</p>
            <p>Arrow functions can be identified by the 'arrow' symbol, => that gives them their name. The parameters 
                come before the arrow and the main body of the function comes after. Arrow functions are always 
                anonymous, so if you want to refer to them, you must assign them to a variable. For example, the 
                square function we wrote earlier can be written like so:<br>
                const square = x => x*x;</p>
            <p>Callbacks</p>
            <p>This means that functions can also be given as a parameter to another function. A function that is 
                passed as an argument to another is known as a callback.</p>
            <p>Sorting Arrays With A Callback</p>
            <p>The reason for this is that the numbers are converted into strings and then placed in alphabetical order.</p>
        </li>
        <li>Array Iterators
            <p>The forEach loop is the most convenient way to loop over an Array.</p>
            <p>The map() method is very similar to the forEach() method. It also iterates over an array, and takes a 
                callback function as a parameter that is invoked on each item in the array. This is often used to 
                process data returned from databases in array form, such as adding HTML tags to plain text.<br>
                The difference is that it returns a new array that replaces each value with the return value of the 
                callback function.
            </p>
        </li>
        <li>Filter
            <p>The filter() method returns a new array that only contains items from the original array that return 
                true when passed to the callback. For example, we can filter an array of numbers to just the even 
                numbers</p>
        </li>
    </section>
    <section class="week2-examples">
        <h3>Examples</h3>
        <li><a href="example1.html" target="_blank">Basic programming</a></li>
        <li><a href="example2.html" target="_blank">Arrays, Logic, and Loops</a></li>
        <li><a href="example3.html" target="_blank">Functions</a></li>
    </section>
</body>
</html>